#!/bin/bash

# Colored prompt

if [ -z "$DOCKER" ]; then
    if [ "$UID" == 0 ]; then
        _PS1='\[\033[01;31m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]>> '
    else
        _PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]>> '
    fi
else
    _PS1='\[\033[01;33m\]\u@\h\[\033[00m\]:\[\033[01;35m\]\w\[\033[00m\]>> '
fi

export PS1=$_PS1 # see git prompt below

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# to change caps lock
#xmodmap ~/.xmodmap

# -ixon -ixoff: remove XON/OFF to release Ctrl-s and Ctrl-q
# -ctlecho:     to remove echo of Ctrl-c (^C)
if [ -t 0 ]; then # If not running interactively, don't do anything
    stty -ixon -ixoff -ctlecho
fi

# vman instead of man
vman() {
vim -c "Man $*" -c "silent only" -c "nmap q :q!<cr>"
}

os_codename=`lsb_release -a 2>/dev/null | grep Codename | awk '{print $2}'`
export PATH=$HOME/usr-$os_codename/bin:$PATH
export GOPATH=$HOME/usr-$os_codename

export EDITOR='vim -X'

# Alias
alias ll='ls -lh'
alias la='ls -lha'

alias eduroam='sudo wpa_supplicant -Dwext -iwlp2s0 -c /home/agil/.cat_installer/cat_installer.conf'

#
# Git Prompt
# from http://blog.deadlypenguin.com/blog/2013/10/24/adding-git-status-to-bash/
#

export ENABLE_PROMPT_GIT=1  # set it to 0 in the terminal to disable the git prompt
export ENABLE_PROMPT_ERR=1  # set it to 0 in the terminal to disable the return code error prompt
export ENABLE_PROMPT_VENV=1 # set it to 0 in the terminal to disable the venv prompt

#
# Define some colors first: Capitals denote bold
#
red='\e[0;31m'
RED='\e[1;31m'
green='\e[0;32m'
GREEN='\e[1;32m'
yellow='\e[0;33m'
YELLOW='\e[1;33m'
blue='\e[0;34m'
BLUE='\e[1;34m'
magenta='\e[0;35m'
MAGENTA='\e[1;35m'
cyan='\e[0;36m'
CYAN='\e[1;36m'
NC='\e[0m'              # No Color


# Taken from http://www.opinionatedprogrammer.com/2011/01/colorful-bash-prompt-reflecting-git-status/
function _git_prompt() {

  if [[ "$ENABLE_PROMPT_GIT" == 1 ]]; then
      local git_status="`git status -unormal 2>&1`"
      if ! [[ "$git_status" =~ Not\ a\ git\ repo ]]; then
        if [[ "$git_status" =~ nothing\ to\ commit ]]; then
          local ansi=$GREEN
        elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
          local ansi=$YELLOW
        else
          local ansi=$RED
        fi
        if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
          branch=${BASH_REMATCH[1]}
          #test "$branch" != master || branch=' '
        else
          # Detached HEAD.  (branch=HEAD is a faster alternative.)
          branch="(`git describe --all --contains --abbrev=4 HEAD 2> /dev/null ||
          echo HEAD`)"
        fi
        echo -n '[\['"$ansi"'\]'"$branch"'\[\e[0m\]] '
      fi
  fi
}
function _virtualenv_prompt() {
  if [[ "$ENABLE_PROMPT_VENV" == 1 ]]; then
    if [[ $VIRTUAL_ENV ]] ; then
        BASE_VENV=`basename $VIRTUAL_ENV`
        echo -ne "(\[$CYAN\]$BASE_VENV\[$NC\]) "
    fi
  fi
}

function report_status() {
  if [[ "$ENABLE_PROMPT_ERR" == 1 ]]; then
     RET_CODE=$?
     COLOR=$NC
     if [[ $RET_CODE -ne 0 ]] ; then
         COLOR=$RED
     fi
     echo -ne "[\[$COLOR\]$RET_CODE\[$NC\]] "
 fi
}

# export PS2="\[$NC\]> "
export PROMPT_COMMAND='_status=$(report_status);export PS1="${_status}$(_virtualenv_prompt)$(_git_prompt)${_PS1}";unset _status;'


#
# Rclone helpers
#
rclone-pull() {
    rclone_filter="";
    local_path=`realpath "./${1}"`
    rclone_path="${local_path}"
    rclone_remote=`echo ${PWD/#$HOME/} | cut -d "/" -f2`;
    rclone_path=`echo ${rclone_path/#$HOME\/$rclone_remote/}`;

    if [ -f "${local_path}" ]; then
        is_file=1
    else
        if [ -d "${local_path}" ]; then
            is_file=0
        else
#             echo "Getting remote size..."
#             is_file=`rclone size "${rclone_remote}:${rclone_path}" | grep objects | sed 's/Total objects: //'`
            rclone rmdir "${rclone_remote}:${rclone_path}" --dry-run
            is_file=$?
        fi
    fi

    if [ "${is_file}" == 1 ]; then
        local_path=`dirname "${local_path}"`
    else
        rclone_filter=${HOME}/${rclone_remote}/.rclone.filter
        if [ -e ${rclone_filter} ]; then
            rclone_filter=" --filter-from ${rclone_filter}"
        else
            rclone_filter=""
        fi
    fi

    cmd=`echo rclone sync \"${rclone_remote}:${rclone_path}\" \"${local_path}\" --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2}`;
    echo $cmd;

    rclone           sync  "${rclone_remote}:${rclone_path}"   "${local_path}"  --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2} --dry-run ;
    echo "Overwriting LOCAL files. Sure?";
    read sure;
    if [ "$sure" = "y"  ]; then
        rclone       sync "${rclone_remote}:${rclone_path}"    "${local_path}"  --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2} -v;
    else
        echo "Aborted";
    fi;
}

rclone-push() {
    rclone_filter="";
    local_path=`realpath "./${1}"`
    rclone_remote=`echo ${PWD/#$HOME/} | cut -d "/" -f2`;

    if [ -f "${local_path}" ]; then
        rclone_path=`dirname "${local_path}"`
    else
        rclone_path="${local_path}"
        rclone_filter=${HOME}/${rclone_remote}/.rclone.filter
        if [ -e ${rclone_filter} ]; then
            rclone_filter=" --filter-from ${rclone_filter}"
        else
            rclone_filter=""
        fi
    fi
    rclone_path=`echo ${rclone_path/#$HOME\/$rclone_remote/}/`;

    cmd=`echo rclone sync \"${local_path}\" \"${rclone_remote}:${rclone_path}\" --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2}`;
    echo $cmd;
    rclone           sync  "${local_path}"   "${rclone_remote}:${rclone_path}"  --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2} --dry-run;
    echo "Overwriting REMOTE files. Sure?";
    read sure;
    if [ "$sure" = "y"  ]; then
        rclone       sync  "${local_path}"   "${rclone_remote}:${rclone_path}"  --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2} -v;
    else
        echo "Aborted";
    fi;
}

rclone-status() {
    rclone_filter="";
    local_path=`realpath "./${1}"`
    rclone_remote=`echo ${PWD/#$HOME/} | cut -d "/" -f2`;

    if [ -f "${local_path}" ]; then
        rclone_path=`dirname "${local_path}"`
    else
        rclone_path="${local_path}"
        rclone_filter=${HOME}/${rclone_remote}/.rclone.filter
        if [ -e ${rclone_filter} ]; then
            rclone_filter=" --filter-from ${rclone_filter}"
        else
            rclone_filter=""
        fi
    fi
    rclone_path=`echo ${rclone_path/#$HOME\/$rclone_remote/}/`;

    cmd=`echo rclone check \"${local_path}\" \"${rclone_remote}:${rclone_path}\" --ignore-size --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2}`;
    echo $cmd;
    rclone           check  "${local_path}"   "${rclone_remote}:${rclone_path}"  --ignore-size --drive-skip-gdocs --track-renames ${rclone_filter} ${@:2};
}

